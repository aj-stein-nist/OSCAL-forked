<?xml version="1.0" encoding="UTF-8"?>
<!-- autogenerated 2022-02-14T18:06:16.451635-05:00 following model in example-set.xspec-->
<?xml-model href="lib/xspec-test-dev.sch" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<?xml-stylesheet type="text/css" href="lib/xspec-oxygen.css"?>
<?specification profile-resolution-specml-working.xml?>
<x:description xmlns:x="http://www.jenitennison.com/xslt/xspec"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"
               xmlns:opr="http://csrc.nist.gov/ns/oscal/profile-resolution"
               stylesheet="../../utils/util/resolver-pipeline/oscal-profile-RESOLVE.xsl"
               run-as="external">
   <x:helper stylesheet="lib/oscal-profile-test-helper.xsl"/>
   <x:scenario
            label="Testing req-phase-order_01.xml: It is strongly RECOMMENDED that implementations execute the following steps in the order that they are provided here (import, merge, modify)."
            pending="clarification">
            <?requirement req-phase-order?>
            <x:context href="requirement-tests/req-phase-order_01.xml"/>
            <x:expect label="Resolution of req-phase-order_01.xml" select="opr:scrub(.)"
                  href="requirement-tests/output-expected/req-phase-order_01_RESOLVED.xml"/>
      </x:scenario>
   <x:scenario label="Testing req-uri-resolve_01.xml: Tools MUST resolve URIs by following Section 5 of RFC3986, with the exception of URI Fragments (URIs that start with &#34;#&#34;). URI Fragments MUST instead be resolved as defined in [Section internalref]."
               pending="deployment">
      <?requirement req-uri-resolve?>
      <x:context href="requirement-tests/req-uri-resolve_01.xml"/>
      <x:expect label="Resolution of req-uri-resolve_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-uri-resolve_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-uri-aquire_01.xml: Tools MUST acquire resources at the resolved URI by following Section 5 of RFC3986, with the exception of URI Fragments (URIs that start with &#34;#&#34;). URI Fragments MUST instead be acquired as defined in [Section internalref]."
               pending="deployment">
      <?requirement req-uri-aquire?>
      <x:context href="requirement-tests/req-uri-aquire_01.xml"/>
      <x:expect label="Resolution of req-uri-aquire_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-uri-aquire_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-uri-base_01.xml: For the purposes of resolving URIs using the above specification, the Base URI MUST be considered to be the absolute URI of the containing profile."
               pending="deployment">
      <?requirement req-uri-base?>
      <x:context href="requirement-tests/req-uri-base_01.xml"/>
      <x:expect label="Resolution of req-uri-base_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-uri-base_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-uri-error_01.xml: In the case that acquiring a resource fails, the tool MUST cease processing and provide an error. In order to ensure profile resolution results in the same catalog regardless of which tool resolves it, all imports must successfully resolve. While this may cause inconvenience if resources are frequently not available, it ensures interoperability."
               pending="deployment">
      <?requirement req-uri-error?>
      <x:context href="requirement-tests/req-uri-error_01.xml"/>
      <x:expect label="Resolution of req-uri-error_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-uri-error_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-internal_01.xml: In the context of the Import Phase, internal references will only appear as a reference to a profile or catalog that is in the resources section of the source. When tools encounter such a reference, they MUST locate the object in resources with the matching ID value, and resolve the import using the rlink URI and the above resolution requirements."
               pending="deployment">
      <?requirement req-internal?>
      <x:context href="requirement-tests/req-internal_01.xml"/>
      <x:expect label="Resolution of req-internal_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-internal_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-internal-error_01.xml: If the object fetched cannot be found or is not a valid OSCAL object, the tool MUST cease processing and provide an error."
               pending="deployment">
      <?requirement req-internal-error?>
      <x:context href="requirement-tests/req-internal-error_01.xml"/>
      <x:expect label="Resolution of req-internal-error_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-internal-error_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-circular-resolve_01.xml: If the resource acquired is an OSCAL Profile, the tool MUST apply this specification to resolve it, then continue processing having imported the resulting catalog."
               pending="deployment">
      <?requirement req-circular-resolve?>
      <x:context href="requirement-tests/req-circular-resolve_01.xml"/>
      <x:expect label="Resolution of req-circular-resolve_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-circular-resolve_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-circular-catalog_01.xml: When a profile imports a profile, the subordinate profile SHOULD be resolved first into a catalog using this specification, before it is imported."
               pending="deployment">
      <?requirement req-circular-catalog?>
      <x:context href="requirement-tests/req-circular-catalog_01.xml"/>
      <x:expect label="Resolution of req-circular-catalog_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-circular-catalog_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-circular-error_01.xml: If a processor encounters a circular import as described above (self-imports are inherently circular), the processor MUST cease processing and generate an error."
               pending="deployment">
      <?requirement req-circular-error?>
      <x:context href="requirement-tests/req-circular-error_01.xml"/>
      <x:expect label="Resolution of req-circular-error_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-circular-error_01_RESOLVED.xml"/>
   </x:scenario>
      <x:scenario
            label="Testing include-all-asis.xml: When an import provides the include-all directive, ALL controls and groups in the referenced document (including nested controls) MUST be included.">
                  <?requirement req-include-all?>
            <x:context href="requirement-tests/req-include-all-asis.xml"/>
            <x:expect label="Resolution of req-include-all_01.xml" select="opr:scrub(.)"
                  href="requirement-tests/output-actual/req-include-all-asis_RESOLVED.xml"/>
      </x:scenario>
      <x:scenario
            label="Testing include-all-flat.xml: When an import provides the include-all directive, ALL controls and groups in the referenced document (including nested controls) MUST be included.">
                  <?requirement req-include-all?>
            <x:context href="requirement-tests/req-include-all-flat.xml"/>
            <x:expect label="Resolution of req-include-all_01.xml" select="opr:scrub(.)"
                  href="requirement-tests/output-actual/req-include-all-flat_RESOLVED.xml"/>
      </x:scenario>
   <x:scenario label="Testing req-include-by-id_01.xml: When an import provides the include-controls directive, with a with-id child, all controls in the referenced document whose id match one of the listed id values MUST be included."
               pending="deployment">
      <?requirement req-include-by-id?>
      <x:context href="requirement-tests/req-include-by-id_01.xml"/>
      <x:expect label="Resolution of req-include-by-id_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-include-by-id_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-include-by-match_01.xml: When an import provides the include-controls directive, with a matching child, all controls in the referenced document whose id matches one of the listed pattern values (Glob matching) MUST be included."
               pending="deployment">
      <?requirement req-include-by-match?>
      <x:context href="requirement-tests/req-include-by-match_01.xml"/>
      <x:expect label="Resolution of req-include-by-match_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-include-by-match_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-include-by-match-empty_01.xml: If a matching object is provided with no pattern, it MUST be treated as matching nothing. While not providing a pattern is technically valid, resolution tool implementers should be aware that it is generally undesirable, and warnings or notices to the user may be appropriate."
               pending="deployment">
      <?requirement req-include-by-match-empty?>
      <x:context href="requirement-tests/req-include-by-match-empty_01.xml"/>
      <x:expect label="Resolution of req-include-by-match-empty_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-include-by-match-empty_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-with-child-controls-yes_01.xml: A with-child-controls: yes directive on an include-controls indicates that all descendant controls of the included control MUST also be included."
               pending="deployment">
      <?requirement req-with-child-controls-yes?>
      <x:context href="requirement-tests/req-with-child-controls-yes_01.xml"/>
      <x:expect label="Resolution of req-with-child-controls-yes_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-with-child-controls-yes_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-with-child-controls-no_01.xml: A with-child-controls: no directive on an include-controls indicates that ONLY the matching control is included, any descendant children MUST NOT be included."
               pending="deployment">
      <?requirement req-with-child-controls-no?>
      <x:context href="requirement-tests/req-with-child-controls-no_01.xml"/>
      <x:expect label="Resolution of req-with-child-controls-no_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-with-child-controls-no_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-with-child-controls-none_01.xml: If no with-child-controls is provided, the processor MUST consider the directive as being equivalent to one having with-child-controls:no."
               pending="deployment">
      <?requirement req-with-child-controls-none?>
      <x:context href="requirement-tests/req-with-child-controls-none_01.xml"/>
      <x:expect label="Resolution of req-with-child-controls-none_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-with-child-controls-none_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-with-parent-controls-yes_01.xml: A with-parent-controls: yes directive on an include-controls indicates that all parent controls of the included control MUST also be included."
               pending="deployment">
      <?requirement req-with-parent-controls-yes?>
      <x:context href="requirement-tests/req-with-parent-controls-yes_01.xml"/>
      <x:expect label="Resolution of req-with-parent-controls-yes_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-with-parent-controls-yes_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-with-parent-controls-no_01.xml: A with-parent-controls: no directive on an include-controls indicates that ONLY the matching control is included, any parents MUST NOT be included."
               pending="deployment">
      <?requirement req-with-parent-controls-no?>
      <x:context href="requirement-tests/req-with-parent-controls-no_01.xml"/>
      <x:expect label="Resolution of req-with-parent-controls-no_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-with-parent-controls-no_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-with-parent-controls-none_01.xml: If no with-parent-controls is provided, the processor MUST consider the directive as being equivalent to one having with-parent-controls:yes."
               pending="deployment">
      <?requirement req-with-parent-controls-none?>
      <x:context href="requirement-tests/req-with-parent-controls-none_01.xml"/>
      <x:expect label="Resolution of req-with-parent-controls-none_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-with-parent-controls-none_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-exclude_01.xml: Any control designated to be both included and excluded, MUST be excluded. This holds irrespective of the specificity of the selection for inclusion or exclusion."
               pending="deployment">
      <?requirement req-exclude?>
      <x:context href="requirement-tests/req-exclude_01.xml"/>
      <x:expect label="Resolution of req-exclude_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-exclude_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-exclude-additional_01.xml: When exclude-controls has at least one with-ids or matching directive, the processor MUST follow the same rules as defined in the relevant sections above for these directives, but exclude instead of include any controls. All optional features (with-child-controls, etc.) also apply to exclusion directives."
               pending="deployment">
      <?requirement req-exclude-additional?>
      <x:context href="requirement-tests/req-exclude-additional_01.xml"/>
      <x:expect label="Resolution of req-exclude-additional_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-exclude-additional_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-redundant_01.xml: A given import may have any number of inclusion statements and any number of exclusion statements. Their effect is cumulative; any control that is included (or excluded) more than once MUST be considered to be included (or excluded) only once. In other words, a given control being included or excluded more than once has no effect. Exclusion still takes priority over inclusion (see above)."
               pending="deployment">
      <?requirement req-redundant?>
      <x:context href="requirement-tests/req-redundant_01.xml"/>
      <x:expect label="Resolution of req-redundant_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-redundant_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-loose-param_01.xml: All loose params from both imported documents and the profile source MUST be included. These params will be kept in the final output if document contains any references to them, and discarded otherwise. See [Section cleanup]."
               pending="deployment">
      <?requirement req-loose-param?>
      <x:context href="requirement-tests/req-loose-param_01.xml"/>
      <x:expect label="Resolution of req-loose-param_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-loose-param_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-merge-order_01.xml: It is RECOMMENDED that tools apply the &#34;combine&#34; directive to the intermediate generated by the Import phase first, then apply the &#34;structuring&#34; directive."
               pending="deployment">
      <?requirement req-merge-order?>
      <x:context href="requirement-tests/req-merge-order_01.xml"/>
      <x:expect label="Resolution of req-merge-order_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-merge-order_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-merge-combine_01.xml: Note that &#34;merge: combine&#34; is deprecated, and MUST be considered undefined behavior when encountered."
               pending="deployment">
      <?requirement req-merge-combine?>
      <x:context href="requirement-tests/req-merge-combine_01.xml"/>
      <x:expect label="Resolution of req-merge-combine_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-merge-combine_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-merge-none_01.xml: If no merge directive is given in the profile, or if a merge is given without a combine, merge conflicts MUST be treated as if method: keep was given."
               pending="deployment">
      <?requirement req-merge-none?>
      <x:context href="requirement-tests/req-merge-none_01.xml"/>
      <x:expect label="Resolution of req-merge-none_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-merge-none_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-merge-keep_01.xml: When a merge is indicated by method:keep, or when no merge directive is given, the keep combination rule is used. Any controls with the same distinctive ID [Section id] MUST NOT not merged. (They are kept.)"
               pending="deployment">
      <?requirement req-merge-keep?>
      <x:context href="requirement-tests/req-merge-keep_01.xml"/>
      <x:expect label="Resolution of req-merge-keep_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-merge-keep_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-merge-keep-warning_01.xml: Processors SHOULD provide a warning under the merge:keep directive when duplicate controls are detected."
               pending="deployment">
      <?requirement req-merge-keep-warning?>
      <x:context href="requirement-tests/req-merge-keep-warning_01.xml"/>
      <x:expect label="Resolution of req-merge-keep-warning_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-merge-keep-warning_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-merge-keep-error_01.xml: The processor MAY throw an error and cease processing (short-circuiting a certain future error) when duplicate controls are detected under the merge:keep directive."
               pending="deployment">
      <?requirement req-merge-keep-error?>
      <x:context href="requirement-tests/req-merge-keep-error_01.xml"/>
      <x:expect label="Resolution of req-merge-keep-error_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-merge-keep-error_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-merge-use-first_01.xml: When the use-first combination rule is applied, and controls that share a distinctive ID are found, the first control encountered MUST be kept, the rest MUST be discarded.First MUST be determined by a top-down, depth-first traversal of the source profile's import hierarchy."
               pending="deployment">
      <?requirement req-merge-use-first?>
      <x:context href="requirement-tests/req-merge-use-first_01.xml"/>
      <x:expect label="Resolution of req-merge-use-first_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-merge-use-first_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-stucture_01.xml: Optionally, one of three &#34;structuring&#34; directives can be included as a child of merge:flat,as-is and custom. When one of these appears, it is the selected structuring directive. If more than one appears, processors MUST generate an error and cease processing."
               pending="deployment">
      <?requirement req-stucture?>
      <x:context href="requirement-tests/req-stucture_01.xml"/>
      <x:expect label="Resolution of req-stucture_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-stucture_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-structure-none_01.xml: If no merge directive is given in the profile, or if a merge is given without a structuring directive, structuring the output MUST be treated as if the structuring directive flat was given. For example, a profile with no merge directive:"
               pending="deployment">
      <?requirement req-structure-none?>
      <x:context href="requirement-tests/req-structure-none_01.xml"/>
      <x:expect label="Resolution of req-structure-none_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-structure-none_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-merge-flat_01.xml: Profiles with the &#34;flat&#34; merge directive MUST be resolved as unstructured catalogs, with no grouping or nesting of controls."
               pending="deployment">
      <?requirement req-merge-flat?>
      <x:context href="requirement-tests/req-merge-flat_01.xml"/>
      <x:expect label="Resolution of req-merge-flat_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-merge-flat_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-merge-flat-list_01.xml: Unstructured catalog output MUST be produced by adhering to the following requirements:"
               pending="deployment">
      <?requirement req-merge-flat-list?>
      <x:context href="requirement-tests/req-merge-flat-list_01.xml"/>
      <x:expect label="Resolution of req-merge-flat-list_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-merge-flat-list_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-merge-flat-list-1_01.xml: All included controls are output to the target as a flat list directly under &#34;catalog&#34;."
               pending="deployment">
      <?requirement req-merge-flat-list-1?>
      <x:context href="requirement-tests/req-merge-flat-list-1_01.xml"/>
      <x:expect label="Resolution of req-merge-flat-list-1_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-merge-flat-list-1_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-merge-flat-list-2_01.xml: Any included &#34;loose params&#34; are output to the target as a flat list directly under &#34;catalog&#34;."
               pending="deployment">
      <?requirement req-merge-flat-list-2?>
      <x:context href="requirement-tests/req-merge-flat-list-2_01.xml"/>
      <x:expect label="Resolution of req-merge-flat-list-2_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-merge-flat-list-2_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-merge-flat-list-3_01.xml: Any groups are discarded."
               pending="deployment">
      <?requirement req-merge-flat-list-3?>
      <x:context href="requirement-tests/req-merge-flat-list-3_01.xml"/>
      <x:expect label="Resolution of req-merge-flat-list-3_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-merge-flat-list-3_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing id-structure-as-is-list_01.xml: Processors MUST handle the as-is directive by adhering to the following requirements:"
               pending="deployment">
      <?requirement id-structure-as-is-list?>
      <x:context href="requirement-tests/id-structure-as-is-list_01.xml"/>
      <x:expect label="Resolution of id-structure-as-is-list_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/id-structure-as-is-list_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing id-structure-as-is-list-1_01.xml: All included controls are output to the target, keeping the structure of the groups and nested controls. Any group that holds an included control MUST appear in the output with all of its non-control children intact. If an included control has a parent control that was not included, that control's output location is &#34;up-leveled&#34;, or made equal to the non-included parent. This applies recursively until the control is directly under either &#34;catalog&#34; or another included control."
               pending="deployment">
      <?requirement id-structure-as-is-list-1?>
      <x:context href="requirement-tests/id-structure-as-is-list-1_01.xml"/>
      <x:expect label="Resolution of id-structure-as-is-list-1_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/id-structure-as-is-list-1_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing id-structure-as-is-list-2_01.xml: Any included &#34;loose params&#34; are output to the target as a flat list directly under &#34;catalog&#34;."
               pending="deployment">
      <?requirement id-structure-as-is-list-2?>
      <x:context href="requirement-tests/id-structure-as-is-list-2_01.xml"/>
      <x:expect label="Resolution of id-structure-as-is-list-2_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/id-structure-as-is-list-2_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-custom-group_01.xml: A group object given under custom MUST result in a group with the exact same content (excluding insert-controls) in the target catalog."
               pending="deployment">
      <?requirement req-custom-group?>
      <x:context href="requirement-tests/req-custom-group_01.xml"/>
      <x:expect label="Resolution of req-custom-group_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-custom-group_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-custom-group-contents_01.xml: If the ID of the group matches the ID of a group that has been included during the import phase, all contents inside the group, including title,param,prop and part objects MUST be copied into the target, appearing in the same order as in the source."
               pending="deployment">
      <?requirement req-custom-group-contents?>
      <x:context href="requirement-tests/req-custom-group-contents_01.xml"/>
      <x:expect label="Resolution of req-custom-group-contents_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-custom-group-contents_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-custom-select_01.xml: When processing the control selection of a custom element, the behavior defined in this section MUST be followed to generate the output."
               pending="deployment">
      <?requirement req-custom-select?>
      <x:context href="requirement-tests/req-custom-select_01.xml"/>
      <x:expect label="Resolution of req-custom-select_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-custom-select_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-custom-select-ignore_01.xml: In the case that a control selection matches none of the included controls, it MUST be ignored."
               pending="deployment">
      <?requirement req-custom-select-ignore?>
      <x:context href="requirement-tests/req-custom-select-ignore_01.xml"/>
      <x:expect label="Resolution of req-custom-select-ignore_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-custom-select-ignore_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-custom-select-warning_01.xml: In the case that a control selection matches none of the included controls, a warning SHOULD be provided."
               pending="deployment">
      <?requirement req-custom-select-warning?>
      <x:context href="requirement-tests/req-custom-select-warning_01.xml"/>
      <x:expect label="Resolution of req-custom-select-warning_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-custom-select-warning_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-set-param-warning_01.xml: If no such parameter is found, a warning SHOULD be issued."
               pending="deployment">
      <?requirement req-modify-set-param-warning?>
      <x:context href="requirement-tests/req-modify-set-param-warning_01.xml"/>
      <x:expect label="Resolution of req-modify-set-param-warning_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-set-param-warning_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-set-param-id-ignore_01.xml: If no such parameter is found, processing MUST still continue."
               pending="deployment">
      <?requirement req-modify-set-param-id-ignore?>
      <x:context href="requirement-tests/req-modify-set-param-id-ignore_01.xml"/>
      <x:expect label="Resolution of req-modify-set-param-id-ignore_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-set-param-id-ignore_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-set-param-objects1_01.xml: For the following objects inside the source: class, depends-on, label, usage, values, select; the object MUST be copied into the target from the source, first removing any existing objects with the same name."
               pending="deployment">
      <?requirement req-modify-set-param-objects1?>
      <x:context href="requirement-tests/req-modify-set-param-objects1_01.xml"/>
      <x:expect label="Resolution of req-modify-set-param-objects1_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-set-param-objects1_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-set-param-objects2_01.xml: For the following objects inside the source: props, links, constraints, guidelines; the contents of the object MUST be added to the contents of the target object of the same name. If no such object exists in the target, it is created."
               pending="deployment">
      <?requirement req-modify-set-param-objects2?>
      <x:context href="requirement-tests/req-modify-set-param-objects2_01.xml"/>
      <x:expect label="Resolution of req-modify-set-param-objects2_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-set-param-objects2_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-set-param-objects3_01.xml: For the following objects inside the source: prop, link; the object MUST be copied into the target from the source, first removing any existing objects with the same distinctive ID. ([Section id])."
               pending="deployment">
      <?requirement req-modify-set-param-objects3?>
      <x:context href="requirement-tests/req-modify-set-param-objects3_01.xml"/>
      <x:expect label="Resolution of req-modify-set-param-objects3_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-set-param-objects3_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-param-multi_01.xml: If more than one set-parameter directive is given for the same parameter, all MUST BE applied, in the sequence given in the profile."
               pending="deployment">
      <?requirement req-modify-param-multi?>
      <x:context href="requirement-tests/req-modify-param-multi_01.xml"/>
      <x:expect label="Resolution of req-modify-param-multi_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-param-multi_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-add-implicit_01.xml: An add directive with no by-id child MUST be considered an implicit binding, and will apply to the control as a whole."
               pending="deployment">
      <?requirement req-modify-alter-add-implicit?>
      <x:context href="requirement-tests/req-modify-alter-add-implicit_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-add-implicit_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-add-implicit_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-add-implicit0contents_01.xml: The contents of an implicitly bound add directive MUST be added to the control contents in the target, either after its title when position is starting, or at the end if its position is ending, or if no valid poisition is given."
               pending="deployment">
      <?requirement req-modify-alter-add-implicit0contents?>
      <x:context href="requirement-tests/req-modify-alter-add-implicit0contents_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-add-implicit0contents_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-add-implicit0contents_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-add-implicit-position_01.xml: When an add directive is implicitly bound, the position values before and after MUST be treated like starting and ending, respectively."
               pending="deployment">
      <?requirement req-modify-alter-add-implicit-position?>
      <x:context href="requirement-tests/req-modify-alter-add-implicit-position_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-add-implicit-position_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-add-implicit-position_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-add-implicit-order_01.xml: After processing an implicitly bound add directive, the control contents MUST be sorted to appear in the required order: a new prop appears after any prop already in the control, when position is ending, or not given, or before any prop in the control when position is starting."
               pending="deployment">
      <?requirement req-modify-alter-add-implicit-order?>
      <x:context href="requirement-tests/req-modify-alter-add-implicit-order_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-add-implicit-order_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-add-implicit-order_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-add-explicit_01.xml: An add directive with a by-id child MUST be considered an explicit binding, and applies to only a single object inside the control."
               pending="deployment">
      <?requirement req-modify-alter-add-explicit?>
      <x:context href="requirement-tests/req-modify-alter-add-explicit_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-add-explicit_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-add-explicit_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-add-explicit-id_01.xml: When an add directive is explitly bound, the value of the by-id child MUST correspond to the value of an id on an object inside the control, and not the control itself."
               pending="deployment">
      <?requirement req-modify-alter-add-explicit-id?>
      <x:context href="requirement-tests/req-modify-alter-add-explicit-id_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-add-explicit-id_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-add-explicit-id_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-add-explicit-id-ignore_01.xml: If by-id does not correspond to such a value, the add directive MUST be considered inoperative and ignored."
               pending="deployment">
      <?requirement req-modify-alter-add-explicit-id-ignore?>
      <x:context href="requirement-tests/req-modify-alter-add-explicit-id-ignore_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-add-explicit-id-ignore_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-add-explicit-id-ignore_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-add-explicit-id-warning_01.xml: An inoperative add directive MAY result in a warning."
               pending="deployment">
      <?requirement req-modify-alter-add-explicit-id-warning?>
      <x:context href="requirement-tests/req-modify-alter-add-explicit-id-warning_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-add-explicit-id-warning_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-add-explicit-id-warning_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-add-explicit-inside_01.xml: When position has a value of starting or ending, the contents of the source MUST be added inside the target, either at the start or end of its contents, respectively."
               pending="deployment">
      <?requirement req-modify-alter-add-explicit-inside?>
      <x:context href="requirement-tests/req-modify-alter-add-explicit-inside_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-add-explicit-inside_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-add-explicit-inside_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-add-explicit-outside_01.xml: When position has a value of before or after, the contents of the source MUST be added outside the target, either directly before or after it, respectively."
               pending="deployment">
      <?requirement req-modify-alter-add-explicit-outside?>
      <x:context href="requirement-tests/req-modify-alter-add-explicit-outside_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-add-explicit-outside_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-add-explicit-outside_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-add-nested_01.xml: Profile Resolution tools MUST be able to correctly handle add directives targetting nested controls. This includes directives that target a child control as well as directives that target a parent control and modify the child."
               pending="deployment">
      <?requirement req-modify-alter-add-nested?>
      <x:context href="requirement-tests/req-modify-alter-add-nested_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-add-nested_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-add-nested_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-remove-match_01.xml: An object inside the control MUST be removed from the output if and only if it meets all of the criteria given by the child objects of the remove directive."
               pending="deployment">
      <?requirement req-modify-alter-remove-match?>
      <x:context href="requirement-tests/req-modify-alter-remove-match_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-remove-match_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-remove-match_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-remove-by-id_01.xml: The remove directive criteria by-id MUST match an object if and only its value is identical to the id value of that object."
               pending="deployment">
      <?requirement req-modify-alter-remove-by-id?>
      <x:context href="requirement-tests/req-modify-alter-remove-by-id_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-remove-by-id_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-remove-by-id_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-remove-name-ref_01.xml: The remove directive criteria name-ref MUST match an object if and only its value is identical to the value of that object's name child."
               pending="deployment">
      <?requirement req-modify-alter-remove-name-ref?>
      <x:context href="requirement-tests/req-modify-alter-remove-name-ref_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-remove-name-ref_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-remove-name-ref_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-remove-ns-ref_01.xml: The remove directive criteria ns-ref MUST match an object if and only its value is identical to the value of that object's ns child."
               pending="deployment">
      <?requirement req-modify-alter-remove-ns-ref?>
      <x:context href="requirement-tests/req-modify-alter-remove-ns-ref_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-remove-ns-ref_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-remove-ns-ref_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-remove-class-ref_01.xml: The remove directive criteria class-ref MUST match an object if and only its value is identical to the value of that object's class child."
               pending="deployment">
      <?requirement req-modify-alter-remove-class-ref?>
      <x:context href="requirement-tests/req-modify-alter-remove-class-ref_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-remove-class-ref_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-remove-class-ref_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-remove-item-name_01.xml: The remove directive criteria item-name MUST match an object if and only its value is identical to the value of that object's serialized name."
               pending="deployment">
      <?requirement req-modify-alter-remove-item-name?>
      <x:context href="requirement-tests/req-modify-alter-remove-item-name_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-remove-item-name_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-remove-item-name_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-modify-alter-remove-item-name-array_01.xml: In serialization formats that use arrays of objects in the OSCAL model, an object's name MUST be considered the singular form of its containing parent array."
               pending="deployment">
      <?requirement req-modify-alter-remove-item-name-array?>
      <x:context href="requirement-tests/req-modify-alter-remove-item-name-array_01.xml"/>
      <x:expect label="Resolution of req-modify-alter-remove-item-name-array_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-modify-alter-remove-item-name-array_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-backmatter_01.xml: The output's backmatter MUST be generated by copying in each resource object from the backmatters of the imported catalogs/profiles in top-to-bottom order, then by copying in each resource object from the backmatter of the source profile itself. These objects MUST be processed in the order they are given in their respective documents."
               pending="deployment">
      <?requirement req-backmatter?>
      <x:context href="requirement-tests/req-backmatter_01.xml"/>
      <x:expect label="Resolution of req-backmatter_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-backmatter_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-backmatter-dupe_01.xml: If a given resource has the same uuid as a resource that has already been added, the previous resource MUST be removed, and the more recent one added, unless superceded by other requirements."
               pending="deployment">
      <?requirement req-backmatter-dupe?>
      <x:context href="requirement-tests/req-backmatter-dupe_01.xml"/>
      <x:expect label="Resolution of req-backmatter-dupe_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-backmatter-dupe_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-backmatter-keep_01.xml: A resource with a child prop of name:keep and value:always MUST NOT be replaced by the addition of another resource, unless the new resource also has a child prop of name:keep and value:always."
               pending="deployment">
      <?requirement req-backmatter-keep?>
      <x:context href="requirement-tests/req-backmatter-keep_01.xml"/>
      <x:expect label="Resolution of req-backmatter-keep_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-backmatter-keep_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-backmatter-prune_01.xml: Tools MAY check for pruning conditions [Section cleanup] as resources are added as long as the final result is the same as if the pruning had taken place at the end of all resource addition."
               pending="deployment">
      <?requirement req-backmatter-prune?>
      <x:context href="requirement-tests/req-backmatter-prune_01.xml"/>
      <x:expect label="Resolution of req-backmatter-prune_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-backmatter-prune_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-meta-uuid_01.xml: The output catalog's metadata MUST have a unique top-level UUID (metadata:uuid). This UUID may be generated as seen fit by the tool, as long as it is reasonable to assume it is globally unique. It is RECOMMENDED that tools use a combination of meaningful text and a uniquely generated value (Ex.{{sourceprofilename}}-RESOLVED-{{GUIDv5}})."
               pending="deployment">
      <?requirement req-meta-uuid?>
      <x:context href="requirement-tests/req-meta-uuid_01.xml"/>
      <x:expect label="Resolution of req-meta-uuid_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-meta-uuid_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-meta-version_01.xml: The value of metadata:version in the target MUST be set with a string that identifies the version of that document."
               pending="deployment">
      <?requirement req-meta-version?>
      <x:context href="requirement-tests/req-meta-version_01.xml"/>
      <x:expect label="Resolution of req-meta-version_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-meta-version_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-meta-version-track_01.xml: The metadata:version SHOULD be used to track updates to this specific output document."
               pending="deployment">
      <?requirement req-meta-version-track?>
      <x:context href="requirement-tests/req-meta-version-track_01.xml"/>
      <x:expect label="Resolution of req-meta-version-track_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-meta-version-track_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-meta-oscal-version_01.xml: The value of metadata:oscal-version in the target MUST be set with a string that identifies the version of OSCAL used by this tool to resolve the profile (ex. 1.0.0). This value MUST be determined by compiling the oscal-versions from each imported document and the source profile, and taking the most recent minor version. If this version is more recent than what the resolution tool is using, then the value of the output oscal-version MUST be the version that the tool used internally."
               pending="deployment">
      <?requirement req-meta-oscal-version?>
      <x:context href="requirement-tests/req-meta-oscal-version_01.xml"/>
      <x:expect label="Resolution of req-meta-oscal-version_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-meta-oscal-version_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-meta-oscalversion-error_01.xml: If any of the above OSCAL versions (imported document versions, source profile version, tool version) are of a different major version (the first digit differs), the tool SHOULD provide an error and cease processing."
               pending="deployment">
      <?requirement req-meta-oscalversion-error?>
      <x:context href="requirement-tests/req-meta-oscalversion-error_01.xml"/>
      <x:expect label="Resolution of req-meta-oscalversion-error_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-meta-oscalversion-error_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-meta-last-modified_01.xml: The value of metadata:last-modified in the target MUST be set with a valid timestamp representing the time the profile resolution completed."
               pending="deployment">
      <?requirement req-meta-last-modified?>
      <x:context href="requirement-tests/req-meta-last-modified_01.xml"/>
      <x:expect label="Resolution of req-meta-last-modified_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-meta-last-modified_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-meta-source-profile_01.xml: The value of metadata:source-profile in the target SHOULD be set with a valid URI that points to the profile that resulted in this catalog."
               pending="deployment">
      <?requirement req-meta-source-profile?>
      <x:context href="requirement-tests/req-meta-source-profile_01.xml"/>
      <x:expect label="Resolution of req-meta-source-profile_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-meta-source-profile_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-meta-source-profile-privacy_01.xml: If there are privacy or security concerns, the value of metadata:source-profile MAY be set to anything, in which case the simple existence of the source-profile property indicates that this is a resolved profile."
               pending="deployment">
      <?requirement req-meta-source-profile-privacy?>
      <x:context href="requirement-tests/req-meta-source-profile-privacy_01.xml"/>
      <x:expect label="Resolution of req-meta-source-profile-privacy_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-meta-source-profile-privacy_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-meta-resolution-tool_01.xml: The value of metadata:resolution-tool in the target SHOULD be set with a string that represents the tool that was used to resolve this catalog."
               pending="deployment">
      <?requirement req-meta-resolution-tool?>
      <x:context href="requirement-tests/req-meta-resolution-tool_01.xml"/>
      <x:expect label="Resolution of req-meta-resolution-tool_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-meta-resolution-tool_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-meta-keep_01.xml: For any metadata:roles or metadata:parties that exist in the source catalogs, if they have a prop child with name:keep and value:always, they are to be copied as is into the output metadata."
               pending="deployment">
      <?requirement req-meta-keep?>
      <x:context href="requirement-tests/req-meta-keep_01.xml"/>
      <x:expect label="Resolution of req-meta-keep_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-meta-keep_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-prune_01.xml: The processor SHOULD prune the resulting output catalog by removing unused objects."
               pending="deployment">
      <?requirement req-prune?>
      <x:context href="requirement-tests/req-prune_01.xml"/>
      <x:expect label="Resolution of req-prune_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-prune_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-prune-keep_01.xml: Any object that has a child prop with a name of &#34;keep&#34; and a value of &#34;always&#34; MUST NOT be pruned."
               pending="deployment">
      <?requirement req-prune-keep?>
      <x:context href="requirement-tests/req-prune-keep_01.xml"/>
      <x:expect label="Resolution of req-prune-keep_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-prune-keep_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-prune-include_01.xml: If an object was explicitly included in the [Section select-phase], it MUST NOT be pruned."
               pending="deployment">
      <?requirement req-prune-include?>
      <x:context href="requirement-tests/req-prune-include_01.xml"/>
      <x:expect label="Resolution of req-prune-include_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-prune-include_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-prune-custom_01.xml: If an object was referenced in a custom section of the source profile, it MUST NOT be pruned."
               pending="deployment">
      <?requirement req-prune-custom?>
      <x:context href="requirement-tests/req-prune-custom_01.xml"/>
      <x:expect label="Resolution of req-prune-custom_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-prune-custom_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-prune-modify_01.xml: If an object was referenced in the modify section of the source profile, it MUST NOT be pruned. Any objects removed in that section are still removed."
               pending="deployment">
      <?requirement req-prune-modify?>
      <x:context href="requirement-tests/req-prune-modify_01.xml"/>
      <x:expect label="Resolution of req-prune-modify_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-prune-modify_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-prune-ref_01.xml: If the object appears in a reference anywhere in the final result catalog, except in other objects that also meet all other pruning criteria, it MUST NOT be removed. A reference to a given object exists if &#34;#{distinctiveID}&#34; appears anywhere, where {distinctiveID} is the distinctive ID of the object [Section id]."
               pending="deployment">
      <?requirement req-prune-ref?>
      <x:context href="requirement-tests/req-prune-ref_01.xml"/>
      <x:expect label="Resolution of req-prune-ref_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-prune-ref_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-reorder_01.xml: Tools MUST reorder the output catalog into canonical order [Section order], except where this specification provides different ordering requirements."
               pending="deployment">
      <?requirement req-reorder?>
      <x:context href="requirement-tests/req-reorder_01.xml"/>
      <x:expect label="Resolution of req-reorder_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-reorder_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-id-id_01.xml: For the objects control, param, and group, distinctiveness MUST be determined by the value of the id child object."
               pending="deployment">
      <?requirement req-id-id?>
      <x:context href="requirement-tests/req-id-id_01.xml"/>
      <x:expect label="Resolution of req-id-id_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-id-id_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-id-uuid_01.xml: For the object resource, distinctiveness MUST be determined by the value of the uuid [Section target-back-matter]."
               pending="deployment">
      <?requirement req-id-uuid?>
      <x:context href="requirement-tests/req-id-uuid_01.xml"/>
      <x:expect label="Resolution of req-id-uuid_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-id-uuid_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-multiformat_01.xml: Profile Resolution tools SHOULD be able to handle source profiles, imported catalogs, and imported profiles that are serialized in XML, JSON, or YAML."
               pending="deployment">
      <?requirement req-multiformat?>
      <x:context href="requirement-tests/req-multiformat_01.xml"/>
      <x:expect label="Resolution of req-multiformat_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-multiformat_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-multiformat-differ_01.xml: A different serialization format of any given input MUST NOT result in a differing output catalog."
               pending="deployment">
      <?requirement req-multiformat-differ?>
      <x:context href="requirement-tests/req-multiformat-differ_01.xml"/>
      <x:expect label="Resolution of req-multiformat-differ_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-multiformat-differ_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-output-xml_01.xml: The final Catalog output, if using XML, MUST be valid as defined by the XML model documentation for the OSCAL Catalog. See the complete XML reference for model requirements."
               pending="deployment">
      <?requirement req-output-xml?>
      <x:context href="requirement-tests/req-output-xml_01.xml"/>
      <x:expect label="Resolution of req-output-xml_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-output-xml_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-output-json_01.xml: The final Catalog output, if using JSON, MUST be valid as defined by the JSON model documentation for the OSCAL Catalog. See the complete JSON reference for model requirements."
               pending="deployment">
      <?requirement req-output-json?>
      <x:context href="requirement-tests/req-output-json_01.xml"/>
      <x:expect label="Resolution of req-output-json_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-output-json_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-output-yaml_01.xml: The final Catalog output, if using YAML, MUST be valid as defined by the JSON model documentation for the OSCAL Catalog."
               pending="deployment">
      <?requirement req-output-yaml?>
      <x:context href="requirement-tests/req-output-yaml_01.xml"/>
      <x:expect label="Resolution of req-output-yaml_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-output-yaml_01_RESOLVED.xml"/>
   </x:scenario>
   <x:scenario label="Testing req-order_01.xml: When the output format is XML, tools MUST use the OSCAL canonical order as described above. When using the YAML or JSON formats, order conveys no meaning, and is not considered important."
               pending="deployment">
      <?requirement req-order?>
      <x:context href="requirement-tests/req-order_01.xml"/>
      <x:expect label="Resolution of req-order_01.xml"
                select="opr:scrub(.)"
                href="requirement-tests/output-expected/req-order_01_RESOLVED.xml"/>
   </x:scenario>
</x:description>
